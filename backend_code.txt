import json
import os
import time
from functools import wraps
from urllib.request import urlopen

from flask import request, jsonify
from jose import jwt

# Load Auth0 configuration from environment variables for better security and flexibility.
# Ensure these are set in your environment (e.g., in a .env file loaded by your run script).
AUTH0_DOMAIN = os.environ.get("AUTH0_DOMAIN")
API_AUDIENCE = os.environ.get("API_AUDIENCE")
ALGORITHMS = ["RS256"]

if not AUTH0_DOMAIN or not API_AUDIENCE:
    raise RuntimeError("AUTH0_DOMAIN and API_AUDIENCE must be set as environment variables.")

# --- Caching for JWKS ---
jwks_cache = {
    "keys": None,
    "expiry": 0
}
CACHE_LIFETIME_SECONDS = 3600 # Cache keys for 1 hour

def get_jwks():
    """
    Retrieves the JSON Web Key Set from Auth0, caching it to avoid excessive requests.
    """
    now = time.time()
    if jwks_cache["keys"] and jwks_cache["expiry"] > now:
        return jwks_cache["keys"]

    jsonurl = urlopen(f"https://{AUTH0_DOMAIN}/.well-known/jwks.json")
    new_jwks = json.loads(jsonurl.read())
    jwks_cache["keys"] = new_jwks
    jwks_cache["expiry"] = now + CACHE_LIFETIME_SECONDS
    return new_jwks

# Decorator to protect endpoints
def token_required(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        auth_header = request.headers.get("Authorization", None)
        if not auth_header:
            return jsonify({
                "error": {"code": "AUTH_HEADER_MISSING", "message": "Authorization header is missing"}
            }), 401

        parts = auth_header.split()
        if parts[0].lower() != "bearer" or len(parts) != 2:
            return jsonify({
                "error": {"code": "INVALID_AUTH_HEADER", "message": "Authorization header must be a Bearer token"}
            }), 401

        token = parts[1]

        try:
            unverified_header = jwt.get_unverified_header(token)
        except jwt.JWTError:
            return jsonify({
                "error": {"code": "INVALID_TOKEN_HEADER", "message": "Invalid token header"}
            }), 401

        jwks = get_jwks()
        rsa_key = {}
        for key in jwks["keys"]:
            if key["kid"] == unverified_header["kid"]:
                rsa_key = {
                    "kty": key["kty"],
                    "kid": key["kid"],
                    "use": key["use"],
                    "n": key["n"],
                    "e": key["e"]
                }
        if not rsa_key:
            return jsonify({
                "error": {"code": "SIGNING_KEY_NOT_FOUND", "message": "Unable to find appropriate key for this token"}
            }), 401

        try:
            jwt.decode(token, rsa_key, algorithms=ALGORITHMS, audience=API_AUDIENCE, issuer=f"https://{AUTH0_DOMAIN}/")
        except jwt.ExpiredSignatureError:
            return jsonify({
                "error": {"code": "TOKEN_EXPIRED", "message": "Token is expired"}
            }), 401
        except (jwt.JWTClaimsError, jwt.JWTError) as e:
            return jsonify({
                "error": {
                    "code": "INVALID_TOKEN_CLAIMS",
                    "message": f"Invalid token claims: {str(e)}"
                }
            }), 401

        return f(*args, **kwargs)
    return decoratedfrom flask import Flask, request, jsonify
from flask_cors import CORS
from dotenv import load_dotenv
import os
from typing import Tuple
from google.api_core import exceptions as google_exceptions
import logging

# Load environment variables from .env file at the very beginning
# This MUST be done before importing other app modules that need the variables.
load_dotenv()

from app.services.analysis_service import analyze_text
from app.models import AnalysisResponse
from app.auth import token_required

app = Flask(__name__)

# This enables Cross-Origin Resource Sharing (CORS), which is necessary
# for your frontend (running on a different port) to communicate with this backend.
CORS(app)

# Setup basic logging for better debugging
logging.basicConfig(level=logging.INFO)

@app.route('/health', methods=['GET'])
def health_check() -> Tuple[str, int]:
    """
    A simple health check endpoint to confirm the service is running.
    """
    return jsonify({"status": "ok"}), 200


@app.route('/api/analyze', methods=['POST'])
@token_required
def analyze() -> Tuple[str, int]:
    data = request.get_json()
    if not data or not data.get('text'):
        return jsonify({
            "error": {
                "code": "BAD_REQUEST",
                "message": "Missing 'text' in request body"
            }
        }), 400

    text_to_analyze = data['text']

    try:
        analysis_result = analyze_text(text_to_analyze)
        return jsonify(analysis_result.dict())
    except google_exceptions.PermissionDenied as e:
        app.logger.error(f"Google API permission denied. Please check your GOOGLE_API_KEY. Details: {e}")
        return jsonify({
            "error": {
                "code": "API_PERMISSION_DENIED",
                "message": "The backend server was denied access by the analysis service. This is likely due to an invalid or restricted API key."
            }
        }), 500
    except Exception as e:
        # In a production environment, you'd want to log the full traceback
        app.logger.exception("An unexpected error occurred during analysis.")
        return jsonify({
            "error": {
                "code": "INTERNAL_SERVER_ERROR",
                "message": f"An unexpected error occurred: {str(e)}"
            }
        }), 500

if __name__ == '__main__':
    # For development, debug=True is fine. For production, use a WSGI server like Gunicorn.
    port = int(os.environ.get('PORT', 5001))
    app.run(debug=True, port=port, host='0.0.0.0')# /backend/app/models.py

from pydantic import BaseModel
from typing import List

class AnalysisRequest(BaseModel):
    """Das Modell für die eingehende Anfrage."""
    text: str

class AnalysisResponse(BaseModel):
    """Das Modell für die ausgehende Antwort."""
    score: int
    problems: List[str]
    summary: strimport os
import re
import google.generativeai as genai # <-- Zurück zur Google-Bibliothek
from app.models import AnalysisResponse

def _parse_gemini_response(reply: str) -> AnalysisResponse:
    """
    Parses the raw text response from Gemini into a structured AnalysisResponse object.
    """
    pattern = re.compile(
        r"Score:\s*(\d+)\s*Probleme:\s*(.*?)\s*Zusammenfassung:\s*(.*)",
        re.DOTALL | re.IGNORECASE
    )
    match = pattern.search(reply)

    if not match:
        # In a real application, you might want to log the failed response for debugging.
        # import logging
        # logging.warning(f"Could not parse Gemini response: {reply}")
        raise ValueError(f"Konnte die Antwort von Gemini nicht parsen. Antwort war: {reply}")

    score = int(match.group(1).strip())
    issues_text = match.group(2).strip()
    # This list comprehension is effective for extracting bullet points.
    issues = [line.strip("- ") for line in issues_text.split('\n') if line.strip() and line.strip().startswith('-')]
    summary = match.group(3).strip()

    return AnalysisResponse(score=score, problems=issues, summary=summary)


def analyze_text(text: str) -> AnalysisResponse:
    """
    Analysiert einen SAP-Instandhaltungstext mit der Google Gemini API.
    """
    # Load API key from .env file
    api_key = os.getenv("GOOGLE_API_KEY")
    if not api_key:
        raise ValueError("CRITICAL: GOOGLE_API_KEY environment variable is not set or could not be loaded.")
    genai.configure(api_key=api_key)

    # Der bewährte Prompt für Gemini
    prompt = f"""
    Du bist ein erfahrener GMP-Auditor und bewertest die Qualität von Instandhaltungsmeldungen in einem pharmazeutischen Produktionsbetrieb. Deine Bewertung muss extrem streng sein und sich an den Prinzipien von GMP und Datenintegrität (ALCOA+) orientieren.

    BEWERTUNGSMATRIX:
    - Score 90-100 (Audit-sicher): Alle 5 Säulen (GMP/ALCOA+, Rückverfolgbarkeit, Ursachenanalyse, Produkteinfluss, CAPA mit Vorbeugemassnahme) sind vollständig erfüllt. Alle IDs und Chargennummern sind vorhanden.
    - Score 70-89 (Gut, mit Lücken): Grösstenteils konform, aber es fehlt eine explizite Vorbeugemassnahme oder die Ursachenanalyse ist nicht tiefgehend.
    - Score 40-69 (Mangelhaft): Es fehlt eine klare Bewertung des Produkteinflusses oder die Ursachenanalyse. Kritische IDs (z.B. Chargennummer) fehlen.
    - Score 10-39 (Schwerwiegend mangelhaft): Mehrere Säulen fehlen. Die Rückverfolgbarkeit ist nicht gegeben.
    - Score 0-9 (Ungenügend): Der Eintrag ist für ein GMP-Umfeld völlig unbrauchbar.

    ANALYSIERE DIESEN TEXT:
    "{text}"

    GIB DEINE ANTWORT NUR IN DIESEM EXAKTEN FORMAT ZURÜCK, OHNE WEITERE ERKLÄRUNGEN:
    Score: <int>
    Probleme:
    - <Problem 1>
    - <Problem 2>
    Zusammenfassung: <String>
    """

    try:
        model = genai.GenerativeModel('gemini-1.5-flash-latest')
        generation_config = genai.types.GenerationConfig(temperature=0.1)

        response = model.generate_content(prompt, generation_config=generation_config)
        reply = response.text
        
        return _parse_gemini_response(reply)

    except Exception as e:
        # It's good practice to log the error before re-raising it.
        print(f"Ein Fehler bei der Kommunikation mit der Google Gemini API ist aufgetreten: {e}")
        raise eimport uvicorn
from dotenv import load_dotenv

# Lädt die Umgebungsvariablen (z.B. GOOGLE_API_KEY) aus der .env-Datei
load_dotenv()

if __name__ == "__main__":
    # Startet den Server auf Port 8000, um Konflikte mit dem Frontend zu vermeiden
    uvicorn.run("app.main:app", host="0.0.0.0", port=8000, reload=True)
Flask
Flask-Cors
google-generativeai
python-dotenv
pydantic
python-jose[cryptography]
requestsFROM python:3.11-slim
WORKDIR /app
COPY requirements.txt ./
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8080"]